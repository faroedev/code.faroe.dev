package main

/*
CREATE TABLE record IF NOT EXISTS (key TEXT NOT NULL PRIMARY KEY, value BLOB NOT NULL, counter INTEGER NOT NULL, expires_at INTEGER NOT NULL) STRICT;
*/

import (
	"fmt"
	"io"
	"time"

	"github.com/faroedev/faroe"
	"zombiezen.com/go/sqlite"
	"zombiezen.com/go/sqlite/sqlitex"
)

type sqliteKeyValueStorageStruct struct {
	conn *sqlite.Conn
}

func newSQLiteKeyValueStorage(conn *sqlite.Conn) *sqliteKeyValueStorageStruct {
	storage := &sqliteKeyValueStorageStruct{conn}
	return storage
}

func (sqliteKeyValueStorage *sqliteKeyValueStorageStruct) Get(key string) ([]byte, int32, error) {
	records := []sqliteKeyValueStorageRecordStruct{}
	err := sqlitex.Execute(sqliteKeyValueStorage.conn, "SELECT value, counter, expires_at FROM record WHERE key = ?", &sqlitex.ExecOptions{
		Args: []any{key},
		ResultFunc: func(stmt *sqlite.Stmt) error {
			value, _ := io.ReadAll(stmt.ColumnReader(0))
			counter := stmt.ColumnInt32(1)
			expiresAtUnix := stmt.ColumnInt64(2)

			record := sqliteKeyValueStorageRecordStruct{
				key:		key,
				value:		value,
				counter:	counter,
				expiresAt:	time.Unix(expiresAtUnix, 0),
			}

			records = append(records, record)
			return nil
		},
	})
	if err != nil {
		return nil, 0, fmt.Errorf("failed to execute sqlite query: %s", err.Error())
	}

	if len(records) != 1 {
		return nil, 0, faroe.ErrKeyValueStorageEntryNotFound
	}

	result := records[0]

	if time.Now().Compare(result.expiresAt) >= 0 {
		return nil, 0, faroe.ErrKeyValueStorageEntryNotFound
	}

	return result.value, result.counter, nil
}

func (sqliteKeyValueStorage *sqliteKeyValueStorageStruct) Set(key string, value []byte, expiresAt time.Time) error {
	err := sqlitex.Execute(sqliteKeyValueStorage.conn, "INSERT INTO record (key, value, counter, expires_at) VALUES (?, ?, ?, ?) ON CONFLICT DO UPDATE SET value = ?, counter = ?, expires_at = ?", &sqlitex.ExecOptions{
		Args: []any{key, value, 0, expiresAt.Unix(), value, 0, expiresAt.Unix()},
	})
	if err != nil {
		return fmt.Errorf("failed to execute sqlite query: %s", err.Error())
	}

	return nil
}

func (sqliteKeyValueStorage *sqliteKeyValueStorageStruct) Add(key string, value []byte, expiresAt time.Time) error {
	err := sqlitex.Execute(sqliteKeyValueStorage.conn, "INSERT INTO record (key, value, counter, expires_at) VALUES (?, ?, ?, ?) ON CONFLICT DO UPDATE SET value = ?, counter = ?, expires_at = ? WHERE expires_at <= ?", &sqlitex.ExecOptions{
		Args: []any{key, value, 0, expiresAt.Unix(), value, 0, expiresAt.Unix(), time.Now().Unix()},
	})
	if err != nil {
		return fmt.Errorf("failed to execute sqlite query: %s", err.Error())
	}

	if sqliteKeyValueStorage.conn.Changes() < 1 {
		return faroe.ErrKeyValueStorageEntryNotFound
	}

	return nil
}

func (sqliteKeyValueStorage *sqliteKeyValueStorageStruct) Update(key string, counter int32, value []byte, expiresAt time.Time) error {
	err := sqlitex.Execute(sqliteKeyValueStorage.conn, "UPDATE record SET value = ?, counter = counter + 1, expires_at = ? WHERE key = ? AND counter = ?", &sqlitex.ExecOptions{
		Args: []any{value, expiresAt.Unix(), key, counter},
	})
	if err != nil {
		return fmt.Errorf("failed to execute sqlite query: %s", err.Error())
	}

	if sqliteKeyValueStorage.conn.Changes() < 1 {
		return faroe.ErrKeyValueStorageEntryNotFound
	}

	return nil
}

func (sqliteKeyValueStorage *sqliteKeyValueStorageStruct) Delete(key string) error {
	err := sqlitex.Execute(sqliteKeyValueStorage.conn, "DELETE FROM record WHERE key = ?", &sqlitex.ExecOptions{
		Args: []any{key},
	})
	if err != nil {
		return fmt.Errorf("failed to execute sqlite query: %s", err.Error())
	}

	if sqliteKeyValueStorage.conn.Changes() < 1 {
		return faroe.ErrKeyValueStorageEntryNotFound
	}

	return nil
}

type sqliteKeyValueStorageRecordStruct struct {
	key			string
	value		[]byte
	counter		int32
	expiresAt	time.Time
}