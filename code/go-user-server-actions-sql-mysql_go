/*
CREATE TABLE app_user (
	id VARCHAR(0) COLLATE utf8mb4_bin PRIMARY KEY, -- TODO: set type (can be ascii), use binary collation
	email_address VARCHAR(100) COLLATE utf8mb4_bin NOT NULL UNIQUE, -- NOTE: can be ascii, use binary collation
	password_hash VARBINARY(255) NOT NULL,
	password_salt VARBINARY(255) NOT NULL,
	password_hash_algorithm_id VARCHAR(127) NOT NULL,
	disabled BOOLEAN NOT NULL DEFAULT FALSE,
	email_address_counter INT NOT NULL DEFAULT 0,
	password_hash_counter INT NOT NULL DEFAULT 0,
	disabled_counter INT NOT NULL DEFAULT 0,
	sessions_counter INT NOT NULL DEFAULT 0
);
*/

package main

import (
	"database/sql"
	"errors"
	"fmt"

	userserver "github.com/faroedev/go-user-server"
)

type actionsStruct struct {
	db *sql.DB
}

func (actions *actionsStruct) CreateUserAction(actionInvocationId string, emailAddress string, passwordHash []byte, passwordHashAlgorithmId string, passwordSalt []byte) (userserver.UserStruct, error) {
	id := generateRandomId()

	_, err := actions.db.Exec("INSERT INTO app_user (id, email_address, password_hash, password_hash_algorithm_id, password_salt) VALUES (?, ?, ?, ?, ?)", id, emailAddress, passwordHash, passwordHashAlgorithmId, passwordSalt)

	if err != nil {
		if isUniqueConstraintError(err) {
			return userserver.UserStruct{}, userserver.NewActionError("email_address_already_used")
		}
		fmt.Println(err)
		return userserver.UserStruct{}, userserver.NewActionError("internal_error")
	}

	user := userserver.UserStruct{
		Id:                      id,
		EmailAddress:            emailAddress,
		PasswordHash:            passwordHash,
		PasswordHashAlgorithmId: passwordHashAlgorithmId,
		PasswordSalt:            passwordSalt,
		DisplayName:             "",
		Disabled:                false,
		EmailAddressCounter:     0,
		PasswordHashCounter:     0,
		DisabledCounter:         0,
		SessionsCounter:         0,
	}
	return user, nil
}

func (actions *actionsStruct) GetUserAction(actionInvocationId string, userId string) (userserver.UserStruct, error) {
	row := actions.db.QueryRow("SELECT email_address, password_hash, password_hash_algorithm_id, password_salt, disabled, email_address_counter, password_hash_counter, disabled_counter, sessions_counter FROM app_user WHERE id = ?", userId)

	var user userserver.UserStruct
	user.Id = userId
	err := row.Scan(
		&user.EmailAddress,
		&user.PasswordHash,
		&user.PasswordHashAlgorithmId,
		&user.PasswordSalt,
		&user.Disabled,
		&user.EmailAddressCounter,
		&user.PasswordHashCounter,
		&user.DisabledCounter,
		&user.SessionsCounter,
	)
	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return userserver.UserStruct{}, userserver.NewActionError("user_not_found")
	}
	if err != nil {
		fmt.Println(err)
		return userserver.UserStruct{}, userserver.NewActionError("internal_error")
	}
	
	return user, nil
}

func (actions *actionsStruct) GetUserByEmailAddressAction(_ string, emailAddress string) (userserver.UserStruct, error) {
	row := actions.db.QueryRow("SELECT id, password_hash, password_hash_algorithm_id, password_salt, disabled, email_address_counter, password_hash_counter, disabled_counter, sessions_counter FROM app_user WHERE email_address = ?", emailAddress)

	var user userserver.UserStruct
	user.EmailAddress = emailAddress
	err := row.Scan(
		&user.Id,
		&user.PasswordHash,
		&user.PasswordHashAlgorithmId,
		&user.PasswordSalt,
		&user.Disabled,
		&user.EmailAddressCounter,
		&user.PasswordHashCounter,
		&user.DisabledCounter,
		&user.SessionsCounter,
	)
	if err != nil && errors.Is(err, sql.ErrNoRows) {
		return userserver.UserStruct{}, userserver.NewActionError("user_not_found")
	}
	if err != nil {
		fmt.Println(err)
		return userserver.UserStruct{}, userserver.NewActionError("internal_error")
	}

	return user, nil
}

func (actions *actionsStruct) UpdateUserEmailAddressAction(_ string, userId string, emailAddress string, userEmailAddressCounter int32) error {
	result, err := actions.db.Exec("UPDATE app_user SET email_address = ?, email_address_counter = email_address_counter + 1 WHERE id = ? AND email_address_counter = ?", emailAddress, userId, userEmailAddressCounter)

	if err != nil {
		if isUniqueConstraintError(err) {
			return userserver.NewActionError("email_address_already_used")
		}
		fmt.Println(err)
		return userserver.NewActionError("internal_error")
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected < 1 {
		return userserver.NewActionError("user_not_found")
	}

	return nil
}

func (actions *actionsStruct) UpdateUserPasswordHashAction(_ string, userId string, passwordHash []byte, passwordHashAlgorithmId string, passwordSalt []byte, userPasswordHashCounter int32) error {
	result, err := actions.db.Exec("UPDATE app_user SET password_hash = ?, password_hash_algorithm_id = ?, password_salt = ?, password_hash_counter = password_hash_counter + 1 WHERE id = ? AND password_hash_counter = ?", passwordHash, passwordHashAlgorithmId, passwordSalt, userId, userPasswordHashCounter)

	if err != nil {
		fmt.Println(err)
		return userserver.NewActionError("internal_error")
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected < 1 {
		return userserver.NewActionError("user_not_found")
	}

	return nil
}

func (actions *actionsStruct) IncrementUserSessionsCounterAction(_ string, userId string, userSessionsCounter int32) error {
	result, err := actions.db.Exec("UPDATE app_user SET sessions_counter = sessions_counter + 1 WHERE id = ? AND sessions_counter = ?", userId, userSessionsCounter)

	if err != nil {
		fmt.Println(err)
		return userserver.NewActionError("internal_error")
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected < 1 {
		return userserver.NewActionError("user_not_found")
	}

	return nil
}

func (actions *actionsStruct) DeleteUserAction(_ string, userId string) error {
	result, err := actions.db.Exec("DELETE FROM app_user WHERE id = ?", userId)
	if err != nil {
		fmt.Println(err)
		return userserver.NewActionError("internal_error")
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected < 1 {
		return userserver.NewActionError("user_not_found")
	}

	return nil
}
